\chapter{Probleml\"osung}

Nachdem im letzten Abschnitt auf mögliche Kriterien zur Messung der relevanten Metrikinformationen eingegangen wurde, erfolgt im folgenden eine spezifische Festlegung auf bestimmte Kriterien, welche auf das zu lösende Problem zugeschnitten werden.

\section{Bestimmung von Daten zur Messung des Startup-Verhaltens von Containern}
\subsection{Kriterienkatalog}
\begin{itemize}
  \item Vorallem Skalierbarkeit und Performance
  \item Transaktionen - Durchsatz wichtig
  \item Deployment egal, da bereits im Container deployed wird
  \item Generell sagen, warum einige Aspekte egal sind
  \item Wartbarkeit nicht so wichtig
  \item Ressourcennutzung
  \item St\"orungsf\"alle (Chaos Monkey)
  \item Non Functionals - Kai hat PDF geschickt
\end{itemize}

\subsubsection{Leistungsfähigkeit}
Die wesentliche Metrik stellt hierbei der Datendurchsatz sowie die Latenzzeit. Die Latenzzeit sollte die komplette Pipeline abdecken, also vom Dateneingang durch den Benutzer, bis hin zur tatsächlichen Abspeicherung der Daten in der Persistenzschicht. Die gesamte Strecke lässt sich allerdings auch in noch kleinere Abschnitte unterteilen um bei unerwarteten Werte festzustellen an welcher Stelle genau es zu einem Engpass kommt. Die Unterteilung der gesamten Pipeline sollte zumindest in zwei Abschnitte erfolgen.

\begin{itemize}
  \item Hierbei ist vorallem von Interesse ob sich die Zeitenrahmen vom Eingang der Daten bis zum Erhalt der Daten durch die Consumer in irgendeiner Weise verändert. Dies sollte zwar nicht der Fall sein, da beide Arten von Testläufen auf die selbe Eingangsschnittstelle zurückgreifen. Dennoch ist es wichtig festzustellen, falls dies dennoch der Fall sein sollte, denn dann handelt es sich um ein tieferliegendes Problem bei der Orchestrierung des Stacks.
  \item Außerdem sollte der Zeitrahmen von Erhalt der Daten durch die Consumer bis hin zur Interaktion mit der Persistenz-Schicht gesondert betrachtet werden. Dieser Abschnitt stellt den variablen Teil der Pipeline dar und ist von größtem Interesse. 
\end{itemize}

\todo{footnote mit link zu gatling und jmeter download seite}
Auf Werkzeuge wie zum Beispiel \emph{Gatling} oder \emph{JMeter} muss hierbei verzichtet werden, da diese nicht in der Lage sind in die Pipeline einzugreifen um die einzelnen Abschnitte gesondert betrachten / messen zu können. Die Metriken müssen sowohl mittels der kompilierten Arbeitsversion als auch der Skript-Version generiert werden um eine Gegenüberstellung anstellen zu können. Hierbei sollte es außerdem möglich sein, den zeitlichen Verlauf der Metriken darzustellen um nachvollziehen zu können, ob es Phasen gibt in denen die Bearbeitung von dem berechneten Durchschnittswert abweicht. Je nach Stärke der Abweichung gilt es zu evaluieren ob weitere statistische Kenngrößen diesbezüglich berechnet werden sollten oder nicht. Ein weiteres mögliches Kriterium wäre in diesem Zusammenhang zum Beispiel die Standardabweichung. Da die Latenzzeit stark mit dem eigentlichen Datendurchsatz zusammenhängt ist es nicht nötig diese noch einmal gesondert zu berechnen um Redundanz zu vermeiden.


\subsubsection{Skalierbarkeit}
Da es sich bei dem Projekt um eine containerisierte Cloudanwendung handelt, muss hierbei eine \emph{Vertikale Skalierung} stattfinden. Um möglichst genaue Werte zu erreichen, müssen die zu skalierenden Container in engem Austausch mit dem System stehen. Es muss festgehalten werden, wann genau der Befehl zum Skalieren getätigt wird, und wann genau ein entsprechender Container gestartet ist. Als vollkommen initialisiert gilt ein Container, wenn neben dem eigenen Filesystem auch sämtliche relevante Kommunikationsschnittstellen gestartet und benötigte Datenverbindungen bestehen. Generell gilt, die erhobenen Metriken sollen jeweils getrennt pro Backend-Technologie erhoben werden um eine Gegenüberstellung zu gewährleisten.

Bezüglich der Skalierung gilt vorallem es soll ein vorausschauendes Regelmodell entworfen werden, welches die Container stufenweise erst dann skaliert, wenn eine Vielzahl von Nachrichten eine gewisse Latenzzeit überschreitet oder der Message Broker eine entsprechende Menge an unbeantworteten Nachrichten hält. Hierbei soll eine sinnvolle Festlegung gefunden werden. Um im Nachhinein genaue Vergleichswerte ermitteln zu können sollen lediglich die Konsumenten Container skaliert werden. Die restlichen Stackkomponenten laufen jeweils mit einer einzigen Instanz.\todo{Im Ausblick erwähnen, dass es möglich ist Datenbanken, Broker etc. zu skalieren, Gegenstand der nächsten Arbeit...} Der Skalierungsprozess soll sowohl mittels eingegangener Nachrichten, als auch durch spezifische Benutzeranfrage, gestartet werden können. Diese Unterteilung soll in den persistierten Datensätzen erkennbar sein.

Die hierbei generierten Metriken sollen sich bezüglich der vom Nachrichteneingang generierten Skalierungen anhand des festgelegten Stufenmodels ausgegeben werden. Hierbei wird der Durchschnitt aller in dieser Stufe / Gruppe enthaltenen Skalierungen gebildet und dargestellt. Es soll allerdings auch möglich sein die durchschnittlichen Werte sowohl für einzelne Containeranzahlen als auch für alle durchlaufen Skalierungen geben. Ähnlich zu den Metriken der \emph{Leistungsfähigkeit} gilt, sie sollen ebenfalls zeitlich aufbereitet werden. Falls sich hierbei ungewöhnlich Auschweifungen hinsichlich der zeitlichen Entwicklung abzeichnen lassen sollten, können weitere statistische Metriken hinzugezogen werden. 

\todo{am Ende schauen ob genügend Zeit um noch die Verlässlichkeit des Systems zu testen. Stichwort Chaos Monkey}


\subsubsection{Zusammenfassung}
Der Übersichtlichtkeitshalber hier noch einmal eine stichwortartige Zusammenfassung der zu ermittelnden Metriken hinsichtlich der betrachteten Kriterien.

\begin{itemize}
  \item Latenzzeit im Durchschnitt sowie als zeitliche Historie
  \begin{itemize}
    \item Abschnitt \emph{vor} Datenaufnahme gesondert betrachten
    \item Abschnitt \emph{nach} Datenaufnahme gesondert betrachten
    \item Gesamte Pipeline betrachten
  \end{itemize}
  \item Skalierungsdauer jeweils pro verwendeter Backend-Technologie festzuhalten
  \begin{itemize}
    \item Skalierung anhand eingehender Nachrichten mittels Stufenmodell
    \item Skalierung mittels direkter Benutzeranfrage (ohne eingehende Nachrichten)
    \item Metriken als Datensätze in einer Datenbank hinterlegt
    \item Durchschnittliche Startzeit pro Containeranzahl 
    \item Durchschnittliche Startzeit pro Skalierungsstufe 
    \item Gesamtdurchschnittliche Startzeit als einzelner Messwert
    \item Metriken als zeitlicher visualisiert
  \end{itemize}
\end{itemize}

\section{Implementierung Prototyp}

\begin{figure}
	\centering
	\includegraphics[width=\linewidth]{kapitel/problemloesung/_img/overview-bw}
	\caption[Komponenten-Stack im Überblick]{Komponenten-Stack im Überblick}
	\label{fig:stackoverview}
\end{figure}


\subsection{Node.js}
\subsection{Spring Boot}

\section{Implementierung mittels Containerisierungsplattform}
\subsection{Container Lifecycle}
\begin{itemize}
  \item Auf verschiedene Schichten eingehen
  \item Auf Ergebnisse beziehen
\end{itemize}
\subsection{Docker Swarm}

\begin{itemize}
  \item Prototypen im Detail erlaeutern
\end{itemize}


\renewcommand\theadalign{bc}
\renewcommand\theadfont{\bfseries}
\renewcommand\theadgape{\Gape[4pt]}
\renewcommand\cellgape{\Gape[4pt]}


\begin{lstlisting}[language=bash]
cat .env

# qbn: queue bound (level) n
# cbn: container bound (level) n

QB0=15
QB1=30
QB2=100
CB0=1
CB1=5
CB2=10
CB3=30
\end{lstlisting}


\begin{tabularx}
  {\textwidth}
  { X | X | X | X | X }
  % {p{0.2\textwidth} | X | X | X | X }
  % {
  %   |p{0.32\textwidth-2\tabcolsep}
  %   |p{0.17\textwidth-2\tabcolsep}
  %   |p{0.17\textwidth-2\tabcolsep}
  %   |p{0.17\textwidth-2\tabcolsep}
  %   |p{0.17\textwidth-2\tabcolsep}|}
  % }
  \toprule
      \centering \hspace{4mm} \uline{QL3} \newline \footnotesize \textit{QB2 \textless{} MC} 
    & \centering \hspace{4mm} UP \newline \footnotesize \textit{abs(CB0 -- CB3)} 
    & \centering \hspace{4mm} UP \newline \footnotesize \textit{abs(CB1 -- CB3)} 
    & \centering \hspace{4mm} UP \newline \footnotesize \textit{abs(CB2 -- CB3)} 
    & \centering \hspace{4mm} OK \newline -- 
    \tabularnewline
  \hline
      \centering \hspace{4mm} \uline{QL2} \newline \footnotesize \textit{QB1 \textless{} MC $\leq$ QB2} 
    & \centering \hspace{4mm} UP \newline \footnotesize \textit{abs(CB0 -- CB2)} 
    & \centering \hspace{4mm} UP \newline \footnotesize \textit{abs(CB1 -- CB2)} 
    & \centering \hspace{4mm} OK \newline -- 
    & \centering \hspace{4mm} DOWN \newline \footnotesize \textit{abs(CB2 -- CB3)} 
    \tabularnewline
  \hline
      \centering \hspace{4mm} \uline{QL1} \newline \footnotesize \textit{QB0 \textless{} MC $\leq$ QB1} 
    & \centering \hspace{4mm} UP \newline \footnotesize \textit{abs(CB0 -- CB1)} 
    & \centering \hspace{4mm} OK \newline -- 
    & \centering \hspace{4mm} DOWN \newline \footnotesize \textit{abs(CB1 -- CB2)} 
    & \centering \hspace{4mm} DOWN \newline \footnotesize \textit{abs(CB1 -- CB3)} 
    \tabularnewline
  \hline
      \centering \hspace{4mm} \uline{QL1} \newline \footnotesize \textit{QB0 \textless{} MC $\leq$ QB1} 
    & \centering \hspace{4mm} UP \newline \footnotesize \textit{abs(CB0 -- CB1)} 
    & \centering \hspace{4mm} OK \newline -- 
    & \centering \hspace{4mm} DOWN \newline \footnotesize \textit{abs(CB1 -- CB2)} 
    & \centering \hspace{4mm} DOWN \newline \footnotesize \textit{abs(CB1 -- CB3)} 
    \tabularnewline
  \hline
      \centering \hspace{4mm} \uline{QL0} \newline \footnotesize \textit{QB0 == MC} 
    & \centering \hspace{4mm} OK \newline -- 
    & \centering \hspace{4mm} DOWN \newline \footnotesize \textit{abs(CB0 -- CB1)} 
    & \centering \hspace{4mm} DOWN \newline \footnotesize \textit{abs(CB0 -- CB2)} 
    & \centering \hspace{4mm} DOWN \newline \footnotesize \textit{abs(CB0 -- CB3)} 
    \tabularnewline
  \hline
    & \centering \hspace{4mm} \uline{CL0} \newline \footnotesize \textit{CB0 == MC} 
    & \centering \hspace{4mm} \uline{CL1} \newline \footnotesize \textit{CB0 \textless{} MC $\leq$ CB1} 
    & \centering \hspace{4mm} \uline{CL1} \newline \footnotesize \textit{CB1 \textless{} MC $\leq$ CB2} 
    & \centering \hspace{4mm} \uline{CL1} \newline \footnotesize \textit{CB2 \textless{} MC $\leq$ CB3} \tabularnewline
  \bottomrule
\end{tabularx}

\section{Implementierung Lasttest}
\subsection{Timeline}
\subsection{Testbedingungen}
\begin{itemize}
  \item Kommt in den Anhang
  \item hat Prof. zwar als eigenes Kapitel erwaehnt, bin mir aber nicht sicher ob das wirklich noetig ist
  \item auf welcher Hardware werden Tests durchgefuehrt?
  \item chaos monkey / Stoerfaelle erlaeutern
\end{itemize}

\begin{table}
  \centering
  \caption{Server Specs}
  \bigskip
  \begin{tabular}{ c l }
    \toprule
    Prozessor & Intel(R) Xeon(R) Gold 6226R CPU @ 2.90GHz \\
    \midrule
    Kerne & 6 Prozessoren á 16 Kerne \\
    \midrule
    RAM & 16 GB \\
    \midrule
    Storage & 150 GB \\
    \bottomrule
  \end{tabular}
\end{table}


% \begin{filecontents*}{test.csv}
%   a,b,c,d
%   1,4,5,1
%   2,3,1,5
%   3,5,6,1
%   4,1,4,9
%   5,3,4,7
%   \end{filecontents*}


\begin{tikzpicture}
\begin{axis}[xlabel={Container Anzahl}, ylabel={Startzeit}]
\addplot table [x=id, y=value, col sep=comma] {test.csv};
\addlegendentry{Spring Boot}
\addplot table [x=id, y=value, col sep=comma] {test2.csv};
\addlegendentry{Node.js}
\end{axis}
\end{tikzpicture}

% \begin{filecontents}{\jobname Data.csv}
%   Jahr;CD;MC
%   1990;298;450
%   1991;330;370
%   1992;420;373
%   1993;485;345
%   1994;650;355
%   1995;710;275
%   1996;770;225
%   1997;750;170
%   1998;815;155
%   1999;925;125
%   2000;926;75
%   2001;890;50
%   2002;825;30
%   2003;750;20
%   2004;775;12
%   2005;700;7
%   2006;620;5
%   2007;515;5 
%   \end{filecontents}
%   \documentclass[paper=a4,12pt,version=last]{scrartcl}
%   \usepackage{pgfplots}
   
%   \begin{document}
%   \begin{tikzpicture}
%         \begin{axis}[ymin=0,
%   %         xtick={1990,1991,1992,1993,1994,1995,1996,1997,1998,1999,2000,2001,2002,2003,2004,2005,2006,2007},
%            x tick label style={/pgf/number format/1000 sep=},
%            xlabel={Jahr},
%            y tick label style={/pgf/number format/1000 sep=},
%            ylabel={in Mio. Stück}
%            ]
   
%      \addplot table [y=CD,col sep=semicolon]  {\jobname Data.csv};
%      \addlegendentry{CD}
%      \addplot table [y=MC,col sep=semicolon]  {\jobname Data.csv};
%      \addlegendentry{MC}
  
%         \end{axis}
%      \end{tikzpicture}


\section{Implementierung Visualierung und Monitoring zur Unterst\"utzung der Auswertung}


% \begin{lstlisting}[style=javaStyle,float,caption=Bank - Konstruktor,label=lst:bank_konstruktor]
\begin{lstlisting}[style=javaStyle]
  // standard constructor 
  public Bank(int playerCnt) {
      this.entries = new Entry[playerCnt];
      this.bankSize = playerCnt;
          this.rand = new Random();
  }
  
  // testing constructor - no fileIO
  public Bank(Entry[] entries, Random pseudoRandom) {
      this.entries = entries;
      this.rand = pseudoRandom;
      this.bankSize = entries.length;
  }
  
  // testing constructor - with fileIO
  public Bank(String preallocation, List<Player> players, Random rand) {
      assert null != preallocation && null != players && null != rand;
      this.bankSize = players.size();
      this.entries = new Entry[this.bankSize];
      if (0 < preallocation.length()) {
          String[] singleEntries = preallocation.split(SEPERATOR_STRING_REPRESENTATION);
          int offset = this.bankSize - singleEntries.length;
          for (int i = singleEntries.length - 1; i >= 0; i--) {
              this.entries[i + offset] = new Entry(singleEntries[i], players);
          }
      }
  }
\end{lstlisting}


\begin{lstlisting}[style=bashStyle]
#!/bin/bash

# Add two numeric value
((sum=25+35))

#Print the result
echo $sum
\end{lstlisting}